diff -durN viking-0.9.5.orig/Makefile.am viking-0.9.5/Makefile.am
--- viking-0.9.5.orig/Makefile.am	2008-07-16 21:31:36.000000000 +0200
+++ viking-0.9.5/Makefile.am	2008-07-22 10:41:01.000000000 +0200
@@ -9,7 +9,7 @@
 	./autogen.sh
 	make
 
-bin_SCRIPTS = viking-remote
+bin_SCRIPTS = viking-remote tools/vik_ocget
 
 EXTRA_DIST = \
 	     viking-remote \
diff -durN viking-0.9.5.orig/src/Makefile.am viking-0.9.5/src/Makefile.am
--- viking-0.9.5.orig/src/Makefile.am	2008-07-21 22:55:09.000000000 +0200
+++ viking-0.9.5/src/Makefile.am	2008-07-22 10:41:01.000000000 +0200
@@ -61,6 +61,7 @@
 	datasource_gps.c \
 	datasource_google.c \
 	datasource_gc.c \
+	datasource_oc.c \
 	datasource_bfilter.c \
 	datasources.h \
 	googlesearch.c googlesearch.h \
diff -durN viking-0.9.5.orig/src/datasource_oc.c viking-0.9.5/src/datasource_oc.c
--- viking-0.9.5.orig/src/datasource_oc.c	1970-01-01 01:00:00.000000000 +0100
+++ viking-0.9.5/src/datasource_oc.c	2011-11-09 14:37:10.533372755 +0100
@@ -0,0 +1,213 @@
+/*
+ * viking -- GPS Data and Topo Analyzer, Explorer, and Manager
+ *
+ * Copyright (C) 2003-2005, Evan Battaglia <gtoevan@gmx.net>
+ *
+ * OpenCaching data source by Jacek Konieczny <jajcus@jajcus.net>
+ *
+ * This program is free software; you can redistribute it and/or modify
+ * it under the terms of the GNU General Public License as published by
+ * the Free Software Foundation; either version 2 of the License, or
+ * (at your option) any later version.
+ *
+ * This program is distributed in the hope that it will be useful,
+ * but WITHOUT ANY WARRANTY; without even the implied warranty of
+ * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
+ * GNU General Public License for more details.
+ *
+ * You should have received a copy of the GNU General Public License
+ * along with this program; if not, write to the Free Software
+ * Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA
+ *
+ */
+#ifdef HAVE_CONFIG_H
+#include "config.h"
+#endif
+#include <string.h>
+
+#include <glib/gi18n.h>
+
+#include "viking.h"
+#include "babel.h"
+#include "gpx.h"
+#include "acquire.h"
+
+typedef struct {
+  GtkWidget *host_entry;
+  GtkWidget *num_spin;
+  GtkWidget *center_entry;
+  GtkWidget *kilometers_radius_spin;
+
+  GdkGC *circle_gc;
+  VikViewport *vvp;
+  gboolean circle_onscreen;
+  gint circle_x, circle_y, circle_width;
+} datasource_oc_widgets_t;
+
+
+static gpointer datasource_oc_init ( );
+static void datasource_oc_add_setup_widgets ( GtkWidget *dialog, VikViewport *vvp, gpointer user_data );
+static void datasource_oc_get_cmd_string ( datasource_oc_widgets_t *widgets, gchar **cmd, gchar **input_file_type );	
+static void datasource_oc_cleanup ( datasource_oc_widgets_t *widgets );
+static gchar *datasource_oc_check_existence ();
+
+#define METERSPERMILE 1609.344
+
+VikDataSourceInterface vik_datasource_oc_interface = {
+  N_("Download OpenCaching Geocaches"),
+  N_("OpenCaching Caches"),
+  VIK_DATASOURCE_SHELL_CMD,
+  VIK_DATASOURCE_ADDTOLAYER,
+  VIK_DATASOURCE_INPUTTYPE_NONE,
+  FALSE,
+  TRUE,
+  (VikDataSourceInitFunc)		datasource_oc_init,
+  (VikDataSourceCheckExistenceFunc)	datasource_oc_check_existence,
+  (VikDataSourceAddSetupWidgetsFunc)	datasource_oc_add_setup_widgets,
+  (VikDataSourceGetCmdStringFunc)	datasource_oc_get_cmd_string,
+  (VikDataSourceProgressFunc)		NULL,
+  (VikDataSourceAddProgressWidgetsFunc)	NULL,
+  (VikDataSourceCleanupFunc)		datasource_oc_cleanup,
+  (VikDataSourceOffFunc)               NULL,
+};
+
+void a_datasource_oc_init()
+{
+}
+
+
+static gpointer datasource_oc_init ( )
+{
+  datasource_oc_widgets_t *widgets = g_malloc(sizeof(*widgets));
+  return widgets;
+}
+
+static gchar *datasource_oc_check_existence ()
+{
+  gchar *ocget_location = g_find_program_in_path("vik_ocget");
+  if ( ocget_location ) {
+    g_free(ocget_location);
+    return NULL;
+  }
+  return g_strdup(_("Can't find vik_ocget in path! Check that you have installed vik_ocget correctly."));
+}
+
+static void datasource_oc_draw_circle ( datasource_oc_widgets_t *widgets )
+{
+  gdouble lat, lon;
+  if ( widgets->circle_onscreen ) {
+    vik_viewport_draw_arc ( widgets->vvp, widgets->circle_gc, FALSE,
+		widgets->circle_x - widgets->circle_width/2,
+		widgets->circle_y - widgets->circle_width/2,
+		widgets->circle_width, widgets->circle_width, 0, 360*64 );
+  }
+  /* calculate widgets circle_x and circle_y */
+  /* split up lat,lon into lat and lon */
+  if ( 2 == sscanf ( gtk_entry_get_text ( GTK_ENTRY(widgets->center_entry) ), "%lf,%lf", &lat, &lon ) ) {
+    struct LatLon ll;
+    VikCoord c;
+    gint x, y;
+
+    ll.lat = lat; ll.lon = lon;
+    vik_coord_load_from_latlon ( &c, vik_viewport_get_coord_mode ( widgets->vvp ), &ll );
+    vik_viewport_coord_to_screen ( widgets->vvp, &c, &x, &y );
+    /* TODO: real calculation */
+    if ( x > -1000 && y > -1000 && x < (vik_viewport_get_width(widgets->vvp) + 1000) &&
+	y < (vik_viewport_get_width(widgets->vvp) + 1000) ) {
+      VikCoord c1, c2;
+      gdouble pixels_per_meter;
+
+      widgets->circle_x = x;
+      widgets->circle_y = y;
+
+      /* determine kilometers per pixel */
+      vik_viewport_screen_to_coord ( widgets->vvp, 0, vik_viewport_get_height(widgets->vvp)/2, &c1 );
+      vik_viewport_screen_to_coord ( widgets->vvp, vik_viewport_get_width(widgets->vvp), vik_viewport_get_height(widgets->vvp)/2, &c2 );
+      pixels_per_meter = ((gdouble)vik_viewport_get_width(widgets->vvp)) / vik_coord_diff(&c1, &c2);
+
+      /* this is approximate */
+      widgets->circle_width = gtk_spin_button_get_value_as_float ( GTK_SPIN_BUTTON(widgets->kilometers_radius_spin) )
+		* 1000 * pixels_per_meter * 2;
+
+      vik_viewport_draw_arc ( widgets->vvp, widgets->circle_gc, FALSE,
+		widgets->circle_x - widgets->circle_width/2,
+		widgets->circle_y - widgets->circle_width/2,
+		widgets->circle_width, widgets->circle_width, 0, 360*64 );
+
+      widgets->circle_onscreen = TRUE;
+    } else
+      widgets->circle_onscreen = FALSE;
+  }
+
+  /* see if onscreen */
+  /* okay */
+  vik_viewport_sync ( widgets->vvp );
+}
+
+static void datasource_oc_add_setup_widgets ( GtkWidget *dialog, VikViewport *vvp, gpointer user_data )
+{
+  datasource_oc_widgets_t *widgets = (datasource_oc_widgets_t *)user_data;
+  GtkWidget *host_label, *num_label, *center_label, *kilometers_radius_label;
+  struct LatLon ll;
+  gchar *s_ll;
+
+  host_label = gtk_label_new (_("OpenCaching host:"));
+  widgets->host_entry = gtk_entry_new();
+  num_label = gtk_label_new (_("Number geocaches:"));
+  widgets->num_spin = gtk_spin_button_new ( GTK_ADJUSTMENT(gtk_adjustment_new( 100, 1, 1000, 10, 20, 50 )), 25, 0 );
+  center_label = gtk_label_new (_("Centered around:"));
+  widgets->center_entry = gtk_entry_new();
+  kilometers_radius_label = gtk_label_new ("Kilometers Radius:");
+  widgets->kilometers_radius_spin = gtk_spin_button_new ( GTK_ADJUSTMENT(gtk_adjustment_new( 100, 1, 1000, 5, 20, 50 )), 25, 2 );
+
+  gtk_entry_set_text ( GTK_ENTRY(widgets->host_entry), "opencaching.pl" );
+
+  vik_coord_to_latlon ( vik_viewport_get_center(vvp), &ll );
+  s_ll = g_strdup_printf("%f,%f", ll.lat, ll.lon );
+  gtk_entry_set_text ( GTK_ENTRY(widgets->center_entry), s_ll );
+  g_free ( s_ll );
+
+
+  widgets->vvp = vvp;
+  widgets->circle_gc = vik_viewport_new_gc ( vvp, "#000000", 3 );
+  gdk_gc_set_function ( widgets->circle_gc, GDK_INVERT );
+  widgets->circle_onscreen = FALSE;
+  datasource_oc_draw_circle ( widgets );
+
+  g_signal_connect_swapped ( G_OBJECT(widgets->center_entry), "changed", G_CALLBACK(datasource_oc_draw_circle), widgets );
+  g_signal_connect_swapped ( G_OBJECT(widgets->kilometers_radius_spin), "value-changed", G_CALLBACK(datasource_oc_draw_circle), widgets );
+
+  gtk_box_pack_start ( GTK_BOX(GTK_DIALOG(dialog)->vbox), host_label, FALSE, FALSE, 5 );
+  gtk_box_pack_start ( GTK_BOX(GTK_DIALOG(dialog)->vbox), widgets->host_entry, FALSE, FALSE, 5 );
+  gtk_box_pack_start ( GTK_BOX(GTK_DIALOG(dialog)->vbox), num_label, FALSE, FALSE, 5 );
+  gtk_box_pack_start ( GTK_BOX(GTK_DIALOG(dialog)->vbox), widgets->num_spin, FALSE, FALSE, 5 );
+  gtk_box_pack_start ( GTK_BOX(GTK_DIALOG(dialog)->vbox), center_label, FALSE, FALSE, 5 );
+  gtk_box_pack_start ( GTK_BOX(GTK_DIALOG(dialog)->vbox), widgets->center_entry, FALSE, FALSE, 5 );
+  gtk_box_pack_start ( GTK_BOX(GTK_DIALOG(dialog)->vbox), kilometers_radius_label, FALSE, FALSE, 5 );
+  gtk_box_pack_start ( GTK_BOX(GTK_DIALOG(dialog)->vbox), widgets->kilometers_radius_spin, FALSE, FALSE, 5 );
+  gtk_widget_show_all(dialog);
+}
+
+static void datasource_oc_get_cmd_string ( datasource_oc_widgets_t *widgets, gchar **cmd, gchar **input_file_type )
+{
+  gchar *safe_string = g_shell_quote ( gtk_entry_get_text ( GTK_ENTRY(widgets->center_entry) ) );
+  gchar *safe_host = g_shell_quote ( gtk_entry_get_text ( GTK_ENTRY(widgets->host_entry) ) );
+  *cmd = g_strdup_printf( "vik_ocget -h %s %s %d %.2lf", safe_host, safe_string, 
+	gtk_spin_button_get_value_as_int ( GTK_SPIN_BUTTON(widgets->num_spin) ),
+	gtk_spin_button_get_value_as_float ( GTK_SPIN_BUTTON(widgets->kilometers_radius_spin) ) );
+  *input_file_type = NULL;
+  g_free ( safe_string );
+  g_free ( safe_host );
+}
+
+static void datasource_oc_cleanup ( datasource_oc_widgets_t *widgets )
+{
+  if ( widgets->circle_onscreen ) {
+    vik_viewport_draw_arc ( widgets->vvp, widgets->circle_gc, FALSE,
+		widgets->circle_x - widgets->circle_width/2,
+		widgets->circle_y - widgets->circle_width/2,
+		widgets->circle_width, widgets->circle_width, 0, 360*64 );
+    vik_viewport_sync( widgets->vvp );
+  }
+  g_free ( widgets );
+}
diff -durN viking-0.9.5.orig/src/datasources.h viking-0.9.5/src/datasources.h
--- viking-0.9.5.orig/src/datasources.h	2008-03-16 11:08:21.000000000 +0100
+++ viking-0.9.5/src/datasources.h	2008-07-22 10:41:01.000000000 +0200
@@ -8,4 +8,5 @@
 #ifdef VIK_CONFIG_GEOCACHES
 extern VikDataSourceInterface vik_datasource_gc_interface;
 #endif
+extern VikDataSourceInterface vik_datasource_oc_interface;
 #endif
diff -durN viking-0.9.5.orig/src/menu.xml.h viking-0.9.5/src/menu.xml.h
--- viking-0.9.5.orig/src/menu.xml.h	2008-07-16 21:31:36.000000000 +0200
+++ viking-0.9.5/src/menu.xml.h	2008-07-22 10:41:01.000000000 +0200
@@ -17,6 +17,7 @@
 #ifdef VIK_CONFIG_GEOCACHES
 	"        <menuitem action='AcquireGC'/>"
 #endif
+	"        <menuitem action='AcquireOC'/>"
 	"      </menu>"
 	"      <separator/>"
 	"      <menuitem action='GenImg'/>"
diff -durN viking-0.9.5.orig/src/vikwindow.c viking-0.9.5/src/vikwindow.c
--- viking-0.9.5.orig/src/vikwindow.c	2008-07-21 22:55:09.000000000 +0200
+++ viking-0.9.5/src/vikwindow.c	2008-07-22 10:41:01.000000000 +0200
@@ -1459,6 +1459,11 @@
 }
 #endif
 
+static void acquire_from_oc ( GtkAction *a, VikWindow *vw )
+{
+  a_acquire(vw, vw->viking_vlp, vw->viking_vvp, &vik_datasource_oc_interface );
+}
+
 static void goto_address( GtkAction *a, VikWindow *vw)
 {
   a_google_search(vw, vw->viking_vlp, vw->viking_vvp);
@@ -1921,6 +1926,7 @@
 #ifdef VIK_CONFIG_GEOCACHES
   { "AcquireGC",   NULL,                 N_("Geo_caches"),    	  	  NULL,         N_("Get Geocaches from geocaching.com"),            (GCallback)acquire_from_gc       },
 #endif
+  { "AcquireOC",   NULL,                 N_("OpenCache Geocaches"),    	  	  NULL,         N_("Get Geocaches from opencaching.pl"),            (GCallback)acquire_from_oc       },
   { "Save",      GTK_STOCK_SAVE,         N_("_Save"),                         "<control>S", N_("Save the file"),                                (GCallback)save_file             },
   { "SaveAs",    GTK_STOCK_SAVE_AS,      N_("Save _As"),                      NULL,         N_("Save the file under different name"),           (GCallback)save_file_as          },
   { "GenImg",    GTK_STOCK_CLEAR,        N_("_Generate Image File"),          NULL,         N_("Save a snapshot of the workspace into a file"), (GCallback)draw_to_image_file_cb },
diff -durN viking-0.9.5.orig/tools/vik_ocget viking-0.9.5/tools/vik_ocget
--- viking-0.9.5.orig/tools/vik_ocget	1970-01-01 01:00:00.000000000 +0100
+++ viking-0.9.5/tools/vik_ocget	2008-07-22 10:41:01.000000000 +0200
@@ -0,0 +1,131 @@
+#!/usr/bin/python
+
+#
+# ocget -- Get geocaches (in the GPX format) from OpenCaching.pl
+#
+
+# default host name, overrided by a command line option
+host="opencaching.pl"
+
+import sys
+import getopt
+import urllib, urllib2
+
+def help():
+   print """ocget v0.1
+This program is free software, distributed under the terms of the GNU GPL v2.
+
+Usage: ocget [-u hostname] lat,lon maxnumberofgcs [maxdistance]
+
+Downloads up to maxnumberofgcs at a distance of up to maxdistance from lat,lon.
+
+If hostname is not given "opencaching.pl" will be used.
+
+Happy caching!!!
+"""
+
+try:
+    opts, args = getopt.gnu_getopt(sys.argv[1:], "h:d", ["help"])
+except getopt.GetoptError:
+    # print help information and exit:
+    help()
+    sys.exit(2)
+
+DEBUG = False
+
+for o, a in opts:
+    if o == "-h":
+        host = a
+    if o == "--help":
+        help()
+        sys.exit()
+    if o == "-d":
+        DEBUG = True
+
+if len(args) < 2:
+    help()
+    sys.exit()
+
+#########################
+
+ll = args[0].split(",")
+lat = float(ll[0])
+lon = float(ll[1])
+
+if lat >= 0:
+    lat_NS="N"
+else:
+    lat_NS="S"
+    lat = -lat
+lat_h = int(lat)
+lat_min = (lat - lat_h) * 60
+if lon >= 0:
+    lon_EW="E"
+else:
+    lon_EW="W"
+    lon = -lon
+lon_h = int(lon)
+lon_min = (lon - lon_h) * 60
+
+if len(args) >= 3:
+    maxdist = args[2]
+else:
+    maxdist = "max"
+
+try:
+    maxcaches = int(args[1])
+except ValueError:
+    maxcaches = 100
+
+params = {
+    "latNS": lat_NS,
+    "lat_h": lat_h,
+    "lat_min": lat_min,
+    "lonEW": lon_EW,
+    "lon_h": lon_h,
+    "lon_min": lon_min,
+    "distance": maxdist,
+    "unit": "km",
+    "count": maxcaches,
+    "searchto": "searchbydistance",
+    "showresult": "1",
+    "sort": "bydistance",
+    "output": "gpx",
+}
+
+params = urllib.urlencode(params)
+url = "http://%s/search.php?%s" % (host, params)
+
+#print >>sys.stderr, "url:", url
+#import httplib
+#httplib.HTTPConnection.debuglevel = 1
+
+request = urllib2.Request(url)
+request.add_header('Accept-encoding', 'gzip')
+opener = urllib2.build_opener(urllib2.ProxyHandler, 
+                            urllib2.HTTPDefaultErrorHandler, 
+                            urllib2.HTTPRedirectHandler, 
+                            urllib2.HTTPErrorProcessor)
+f = opener.open(request)
+
+if f.headers.get('Content-Encoding') == "gzip":
+    import StringIO
+    compressedstream = StringIO.StringIO(f.read())
+    import gzip
+    stream = gzip.GzipFile(fileobj=compressedstream)
+    for line in stream:
+        sys.stdout.write(line)
+elif f.headers.get('Content-Disposition').endswith(".zip\""):
+    # workaround for opencaching.de sending ZIP archives
+    print >>sys.stderr, "ZIP file detected, trying to uncompress..."
+    import StringIO
+    compressedstream = StringIO.StringIO(f.read())
+    import zipfile
+    zip = zipfile.ZipFile(compressedstream, "r")
+    first_file = zip.namelist()[0]
+    sys.stdout.write(zip.read(first_file))
+else:
+    for line in f:
+        sys.stdout.write(line)
+
+# vi: et sw=4 sts=4
